"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[51459],{36116:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var n=r(85893),i=r(11151);const o={sidebar_position:5},s="Workflowitem-ordering",a={id:"developer/architecture/workflowitem-ordering",title:"Workflowitem-ordering",description:"Date: 04/05/2018",source:"@site/docs/developer/architecture/0005-workflowitem-ordering.md",sourceDirName:"developer/architecture",slug:"/developer/architecture/workflowitem-ordering",permalink:"/docs/developer/architecture/workflowitem-ordering",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/developer/architecture/0005-workflowitem-ordering.md",tags:[],version:"current",lastUpdatedBy:"MartinJurcoGlina",lastUpdatedAt:1728052976,formattedLastUpdatedAt:"Oct 4, 2024",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Resource-level lifetime",permalink:"/docs/developer/architecture/ressource-level-lifetime"},next:{title:"Multi-node setup",permalink:"/docs/developer/architecture/multi-node-setup"}},l={},c=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"workflowitem-ordering",children:"Workflowitem-ordering"}),"\n",(0,n.jsx)(t.p,{children:"Date: 04/05/2018"}),"\n",(0,n.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,n.jsx)(t.p,{children:"Draft"}),"\n",(0,n.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,n.jsx)(t.p,{children:"Workflowitems are sorted by their creation time by default, but there needs to be some mechanism that allows for manual sorting as well (mainly relevant for the UI). Previously, each workflowitem would hold a pointer to the previous item in the list. However, this approach cannot prevent an inconsistent state if there is a data race between two concurrent requests: it may happen that two workflowitems share the same pointer (turning the list into a tree)."}),"\n",(0,n.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,n.jsx)(t.p,{children:"We solve this by maintaining the ordering as a list, stored with the subproject the workflowitems belong to:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-plain",children:'subproject stream:\n  stream item "workflowitem_ordering" => { data: [id1, id2, ...], log: [], permissions: {}}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Note that we use the resource structure here simply to be able to treat the record like any other, but ",(0,n.jsx)(t.code,{children:"log"})," and ",(0,n.jsx)(t.code,{children:"permissions"})," have no meaning at the time of writing."]}),"\n",(0,n.jsx)(t.p,{children:"Since Multichain doesn't offer transactions for stream operations, we cannot guarantee that a newly created workflowitem would always be recorded in the list, so we apply the following trick when computing the ordering:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Workflowitems that are included in the workflowitem-ordering are included in the result exactly in that ordering;"}),"\n",(0,n.jsx)(t.li,{children:"all remaining workflowitems are sorted by their creation time and appended to the result."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Because workflowitems are sorted by their creation time by default, newly created items ",(0,n.jsx)(t.em,{children:"do not"})," have to be added to the ordering, so no inconsistencies can occur."]}),"\n",(0,n.jsx)(t.h2,{id:"consequences",children:"Consequences"}),"\n",(0,n.jsx)(t.p,{children:"Using this approach, we get the following properties:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Without setting an ordering through an API call, the ordering list is empty and all items are sorted by their creation time."}),"\n",(0,n.jsx)(t.li,{children:"When an ordering is set, it is respected when returning workflowitems."}),"\n",(0,n.jsxs)(t.li,{children:["The case of concurrent requests:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Concurrent creation causes both items to be appended to the list, ordered by their creation time, or in arbitrary order in case the creation times are equal."}),"\n",(0,n.jsx)(t.li,{children:"Concurrent updates of the ordering is a race with all-or-nothing semantics: whoever finished the update last wins, and there can never be any inconsistencies."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"If an update to the ordering does not include a workflowitem that was not present when the request was issued, when returning the ordered list of workflowitems, the missing workflowitem is simply set as the last element (which makes sense: it is the newest workflowitem, after all)."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,r)=>{r.d(t,{Z:()=>a,a:()=>s});var n=r(67294);const i={},o=n.createContext(i);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);