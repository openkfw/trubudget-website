"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8007],{81613:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"developer/architecture/migration-model","title":"Migration Model","description":"Date: 28/11/2018","source":"@site/docs/developer/architecture/0009-migration-model.md","sourceDirName":"developer/architecture","slug":"/developer/architecture/migration-model","permalink":"/docs/developer/architecture/migration-model","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/edit/master/website/docs/developer/architecture/0009-migration-model.md","tags":[],"version":"current","lastUpdatedBy":"SamuelPull","lastUpdatedAt":1730990936000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Git Branching Model","permalink":"/docs/developer/architecture/git-branching-model"},"next":{"title":"Multi node setup and user management","permalink":"/docs/developer/architecture/multi-node-setup-and-user-management"}}');var i=t(74848),o=t(28453);const s={sidebar_position:9},a="Migration Model",d={},c=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Explanation of the current implementation",id:"explanation-of-the-current-implementation",level:3},{value:"Subject for change",id:"subject-for-change",level:3},{value:"Options",id:"options",level:3},{value:"Decision",id:"decision",level:2},{value:"TODOs",id:"todos",level:3},{value:"Change Hex to JSON format",id:"change-hex-to-json-format",level:4},{value:"Set new version in network",id:"set-new-version-in-network",level:4},{value:"Track versions in network",id:"track-versions-in-network",level:4},{value:"Prohibit writing with older version when newer version is set",id:"prohibit-writing-with-older-version-when-newer-version-is-set",level:4},{value:"Consequences",id:"consequences",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"migration-model",children:"Migration Model"})}),"\n",(0,i.jsx)(n.p,{children:"Date: 28/11/2018"}),"\n",(0,i.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,i.jsx)(n.p,{children:"Draft"}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"This ADR discusses how to handle breaking schema changes of the data-model in the context of a distributed application (TruBudget)."}),"\n",(0,i.jsx)(n.h3,{id:"explanation-of-the-current-implementation",children:"Explanation of the current implementation"}),"\n",(0,i.jsx)(n.p,{children:"Data is currently stored in streams. A stream contains none, 1, or multiple items. These items can either represent the complete data-set at time of creation or data change (for example an event). In streams that represent the complete data in every item, the last item represents the current state. In streams where items only contain data changes, the items are sourced from the first to the latest in order to get the current state of the data (event-sourcing)."}),"\n",(0,i.jsxs)(n.p,{children:["Items which represent complete data-sets are called ",(0,i.jsx)(n.code,{children:"Resource"}),". Items which contain only data changes are called ",(0,i.jsx)(n.code,{children:"Event"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to be able to change the interface of ",(0,i.jsx)(n.code,{children:"Event"})," a ",(0,i.jsx)(n.code,{children:"Event.dataVersion"})," field can be defined describing the interface version of the ",(0,i.jsx)(n.code,{children:"Event"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An item of type ",(0,i.jsx)(n.code,{children:"Resource"})," currently doesn't contain a ",(0,i.jsx)(n.code,{children:"dataVersion"})," field. Furthermore it is generally using ",(0,i.jsx)(n.code,{children:"HEX"})," as a dataformat, instead of ",(0,i.jsx)(n.code,{children:"JSON"})," which is used as dataformat for ",(0,i.jsx)(n.code,{children:"EVENTS"})]}),"\n",(0,i.jsxs)(n.p,{children:["For items of type ",(0,i.jsx)(n.code,{children:"Event"})," the dataVersion is only checked when performing a read requests. When performing a write/publish request to streams containing items from type ",(0,i.jsx)(n.code,{children:"Event"})," no check is performed."]}),"\n",(0,i.jsx)(n.h3,{id:"subject-for-change",children:"Subject for change"}),"\n",(0,i.jsxs)(n.p,{children:["Before the upcoming release we want to unify the dataformats. More precisly the plan is to get rid of the ",(0,i.jsx)(n.code,{children:"HEX"})," dataformat and only use ",(0,i.jsx)(n.code,{children:"JSON"}),". Hence, we have to introduce a breaking change regarding in our items of type ",(0,i.jsx)(n.code,{children:"Resource"}),". Items created by a node running the new version of Trubudget will be in ",(0,i.jsx)(n.code,{children:"JSON"})," and can't be read by Nodes running an older version of TruBudget (which is expecting ",(0,i.jsx)(n.code,{children:"HEX"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"For changing the dataformat in the current case there is no technical solution, how to gracefully migrate. Hence, we will do it on an organisational level (updating all versions simultanously)."}),"\n",(0,i.jsx)(n.p,{children:"But for future updates we want to be better prepared handling version conflicts between different distributed nodes in a TruBudget network."}),"\n",(0,i.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,i.jsx)(n.p,{children:"In general we need to distinguish on how data is read from the stream."}),"\n",(0,i.jsxs)(n.p,{children:["For streams containing items of type ",(0,i.jsx)(n.code,{children:"Event"})," and doing event-sourcing the newest version needs to be able to read items of older version. If an older version of a node tries to read a stream which contains items of a newer version, it is not able to do so and returns an error."]}),"\n",(0,i.jsxs)(n.p,{children:["For streams containing items of type ",(0,i.jsx)(n.code,{children:"Resource"})," only the last element is read. It is pretty much the same: New versions can read stream with items of older versions. But not vice-versa. The only difference is: Since only the last item is read from the stream, old data versions could be migrated resulting in removing source-code which is needed to read the older versions of the item."]}),"\n",(0,i.jsx)(n.p,{children:"Things get more complicated for write operations:"}),"\n",(0,i.jsxs)(n.p,{children:["For streams containing items of type ",(0,i.jsx)(n.code,{children:"Event"})," it makes no sense for a node with the old data-version to write, since it might not be able to read it upfront or afterwards."]}),"\n",(0,i.jsxs)(n.p,{children:["For streams containing items of type ",(0,i.jsx)(n.code,{children:"Resource"})," it is pretty much the same."]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(n.p,{children:"Since read and write operation might return errors for nodes running an older dataVersion, these nodes need to be forced to upgrade to a newer version if they still want to participate in the network."}),"\n",(0,i.jsx)(n.p,{children:"This means:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Nodes with older dataVersion are not allowed to write to streams"}),"\n",(0,i.jsx)(n.li,{children:"Nodes with older dataVersion are allowed to read, but might not be able to get the most recent data"}),"\n",(0,i.jsxs)(n.li,{children:["Items of type ",(0,i.jsx)(n.code,{children:"Event"})," or ",(0,i.jsx)(n.code,{children:"Resource"})," extend a DataVersion interface"]}),"\n",(0,i.jsx)(n.li,{children:"The network is aware of all nodes and it's versions (in order to inform them if they run on an old version)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"todos",children:"TODOs"}),"\n",(0,i.jsx)(n.h4,{id:"change-hex-to-json-format",children:"Change Hex to JSON format"}),"\n",(0,i.jsxs)(n.p,{children:["Every item, which is written to a stream has ",(0,i.jsx)(n.code,{children:"JSON"})," as datatype and should extend the ",(0,i.jsx)(n.code,{children:"DataVersion"})," interface (e.g. ",(0,i.jsx)(n.code,{children:"Resource"}),", ",(0,i.jsx)(n.code,{children:"Event"}),", ",(0,i.jsx)(n.code,{children:"Vault"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Use a DataVersion interface for all three interfaces (Event, Resource, Vault)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"interface DataVersion {\ndataVersion: number\n}\n\ninterface Resource extends DataVersion {\n....\n}\n\n"})}),"\n",(0,i.jsx)(n.h4,{id:"set-new-version-in-network",children:"Set new version in network"}),"\n",(0,i.jsx)(n.p,{children:'We create a multichain stream named "versions" where all dataversion should be saved. On startup every node checks its version and updates the stream if it is higher.'}),"\n",(0,i.jsx)(n.p,{children:"streamname : versions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n  keys: ["1"]\n  data: {\n    json: {\n      dataVersion: 1,\n      any: [this is a example of the data-format in this version]\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"track-versions-in-network",children:"Track versions in network"}),"\n",(0,i.jsxs)(n.p,{children:["We currently track all nodes that have been registered in the network. For every node an item is saved to the ",(0,i.jsx)(n.code,{children:"nodes"})," stream. We also have to save an item if the node's dataVersion increases to track versions of every node in the network."]}),"\n",(0,i.jsx)(n.p,{children:'streamname: nodes\nnode-address: "1axuNPTudeCHHBwhJD5tYtRaaGWGpkTon5qd"'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n    "keys" : [\n            "1axuNPTudeCHHBwhJD5tYtRaaGWGpkTon5qd"\n    ],\n    "data" : {\n        "json" : {\n            "key" : "1axuNPTudeCHHBwhJD5tYtRaaGWGpkTon5qd",\n            "intent" : "network.registerNode",\n            "createdBy" : "<system>",\n            "createdAt" : "2018-11-12T09:57:19.104Z",\n            "dataVersion" : 1,\n            "data" : {\n                "address" : "1axuNPTudeCHHBwhJD5tYtRaaGWGpkTon5qd",\n                "organization" : "ACMECorp"\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"prohibit-writing-with-older-version-when-newer-version-is-set",children:"Prohibit writing with older version when newer version is set"}),"\n",(0,i.jsxs)(n.p,{children:["Before every write operation, the version needs to be checked. The most efficient way to do so is to query the streamkeys with ",(0,i.jsx)(n.code,{children:"liststreamkeys"})," of the ",(0,i.jsx)(n.code,{children:"versions"})," stream."]}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"an upgraded node might disable all other nodes because nodes with an older version cannot read/write to the multichain in old data-versions"}),"\n",(0,i.jsxs)(n.li,{children:["all items in any stream have a ",(0,i.jsx)(n.code,{children:"dataVersion"})," field"]}),"\n",(0,i.jsx)(n.li,{children:"version needs to be checked before every write operation"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);