(self.webpackChunkweb=self.webpackChunkweb||[]).push([[5642],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return f}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),d=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),f=r,h=p["".concat(s,".").concat(f)]||p[f]||u[f]||i;return n?o.createElement(h,a(a({ref:t},l),{},{components:n})):o.createElement(h,a({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var d=2;d<i;d++)a[d]=n[d];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6956:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return l},default:function(){return p}});var o=n(2122),r=n(9756),i=(n(7294),n(3905)),a=["components"],c={sidebar_position:12},s="Node Status",d={unversionedId:"developer/architecture/node-connection-info",id:"developer/architecture/node-connection-info",isDocsHomePage:!1,title:"Node Status",description:"Date: 11/03/2021",source:"@site/docs/developer/architecture/0012-node-connection-info.md",sourceDirName:"developer/architecture",slug:"/developer/architecture/node-connection-info",permalink:"/docs/developer/architecture/node-connection-info",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/developer/architecture/0012-node-connection-info.md",version:"current",lastUpdatedBy:"Stezido",lastUpdatedAt:1644233389,formattedLastUpdatedAt:"2/7/2022",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Decline Node Request",permalink:"/docs/developer/architecture/decline-node"},next:{title:"Logging",permalink:"/docs/developer/logging"}},l=[{value:"Status",id:"status",children:[]},{value:"Context",id:"context",children:[]},{value:"Decision",id:"decision",children:[]},{value:"Consequences",id:"consequences",children:[]}],u={toc:l};function p(e){var t=e.components,n=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"node-status"},"Node Status"),(0,i.kt)("p",null,"Date: 11/03/2021"),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"Accepted"),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,'We want to be able to display more info regarding the status of the nodes connected to the network. A useful feature would be to display if a node is still connected or not and also to see a "last seen" timestamp of the nodes.'),(0,i.kt)("h2",{id:"decision"},"Decision"),(0,i.kt)("p",null,"In order for the connection status to be displayed, an endpoint checking the multichain's ",(0,i.kt)("a",{parentName:"p",href:"https://www.multichain.com/developers/json-rpc-api/"},"getpeerinfo")," function would be called. This returns the nodes connected at the moment. However, since MultiChain doesn't provide information about when a node was last seen we want to implement this feature in the api. A new stream should be created called ",(0,i.kt)("inlineCode",{parentName:"p"},"network_log")," and every 24h an event would be saved on the stream displaying the addresses of the nodes connected at that moment. All nodes in the network perform the check but only saves it on the stream if there is no event saved for that day. This way, the check is being recorded even if one of the nodes is disconnected but it is also prevents duplicate entries."),(0,i.kt)("h2",{id:"consequences"},"Consequences"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"network.list")," endpoint also need to be adapted to display the information mentioned above. When nodes are listed, the field ",(0,i.kt)("inlineCode",{parentName:"p"},"isConnected")," should also show the connection status and the ",(0,i.kt)("inlineCode",{parentName:"p"},"lastSeen"),", which shows on what date the node was last connected."))}p.isMDXComponent=!0}}]);